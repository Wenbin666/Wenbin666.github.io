---
title: C语言常见面试题目
date: 2020-11-08 15:54:31
tags: interview
categories: 
 - job
---

### 1.使用 const 关键字修饰一个指针变量可以实现什么样的功能？
1. 指针本身是常量（指针指向不能改变，但指针指向的内容可以改变）
```C
int value = 10;  
int* const ptr = &value;
```
ptr 是一个指向 int 的常量指针。
不能将 ptr 指向另一个地址（即不能改变 ptr 的指向），但是可以通过 ptr 修改它所指向的 value 的值。

2. 指针指向的内容是常量（指针指向可以改变，但指针指向的内容不能改变）
```C
int value = 10;  
const int* ptr = &value;
```
ptr 是一个指向 const int 的指针。
可以将 ptr 指向另一个 int 类型的变量，但是不能通过 ptr 修改它所指向的内容。
注意，即使 value 没有被声明为 const，一旦它被 const int* 类型的指针 ptr 指向，它也就不能通过 ptr 被修改了。

3. 指针本身是常量，且指针指向的内容也是常量（两者都不能改变）
```C
const int value = 10;  
const int* const ptr = &value;
```
ptr 既是一个指向 const int 的指针，又是一个常量指针。
这意味着你既不能改变 ptr 的指向，也不能通过 ptr 修改它所指向的内容。

### 2.switch语句一定必须包含default分支吗？
switch语句**不一定**必须包含default分支。
default分支是可选的，它用于处理那些没有在case标签中明确列出的情况。如果确信switch语句中的每个case都能覆盖所有可能的输入值，或者不关心未明确列出的情况，可以省略default分支。
在编写代码时，包含default分支通常是一个好习惯，因为它可以提供一种方式来处理意外的或未预见到的输入值，比如通过打印错误消息、记录日志或执行一些清理操作。这有助于增强代码的健壮性和可维护性。

### 3.在C语言中，switch语句的case标签可以是哪些类型？

1. 整数类型
整型（int）：最常见的类型，包括正整数、负整数和零。如果switch语句的表达式是整型，那么case标签也必须是整型常量或整型表达式（但实践中通常使用整型常量）。
短整型（short）：在C语言中，短整型也可以作为switch语句的case标签，但前提是switch语句的表达式与case标签的类型兼容。
长整型（long）：类似地，长整型也可以作为case标签，但同样需要确保与switch语句的表达式类型相匹配。
2. 字符类型
字符型（char）：在C语言中，字符型变量或常量也可以作为switch语句的case标签。字符在内部是以ASCII码或其他字符编码的形式存储的，因此它们本质上是整数。这意味着，当你在switch语句中使用字符型变量时，实际上是将其ASCII码值或字符编码值与case标签进行比较。
3. 枚举类型
枚举类型（Enum）：C语言支持枚举类型，它允许程序员定义一组命名的整型常量。在switch语句中，枚举类型的值也可以作为case标签。这使得代码更加清晰和易于维护，因为枚举值具有明确的语义含义。

### 4.do-while 循环语句可以保证循环体至少被执行一次？（判对错）
对，do-while 循环语句确实可以保证循环体至少被执行一次。
因为 do-while 循环的结构是先执行循环体中的代码，然后再判断循环条件是否满足。
如果循环条件为真（true），则继续执行循环体；如果循环条件为假（false），则终止循环。
因此，不论循环条件最初是否为真，循环体中的代码都会至少被执行一次。

### 5.说下strcat和strcpy的作用？
1. strcat()：
```c
char *strcat(char *dest, const char *src);
```
这个函数是字符串拼接函数。strcat() 函数用于将两个字符串连接起来，即把第二个字符串（src）追加到第一个字符串（dest）的末尾，并返回指向第一个字符串的指针。使用时需要确保第一个字符串（dest）有足够的空间来容纳两个字符串合并后的结果，否则可能会导致缓冲区溢出。

2. strcpy()：
```C
char *strcpy(char *dest, const char *src);
```
这个函数并不是字符串拼接函数，而是字符串复制函数。strcpy() 函数用于将一个字符串（src）复制到另一个字符串（dest）中，包括终止的空字符（'\0'）。因此，它并不适用于拼接字符串，而是用于复制字符串。

### 6.说下C语言中“#“和”##”的作用？

”#” 操作符用于将其后的宏参数转换为一个字符串字面量。这意味着，如果宏参数是一个标识符、关键字、数字常量等，
“#” 操作符会将这些内容放在双引号中，形成一个字符串。这对于在宏中生成包含参数名的字符串非常有用。
“##“ 操作符的主要作用是将宏定义中的两个标记（tokens）连接成一个新的标记。这种连接发生在预处理阶段，即编译器正式处理代码之前。通过”##”可以生成具有动态组成部分的标识符，这些标识符在宏展开后将作为单个标记被编译器识别。

### 7.指针可以指向一个已经被释放的内存地址？（正确还是错误）
错误：在理想的编程实践中，一个指针不应该指向一个已经被释放的内存地址。
一旦内存被释放，它就不再属于自己的程序，并且可能会被操作系统重新分配给其他程序或自己程序中的其他部分。
如果此时你的程序还通过原来的指针访问这块内存，那么这将导致未定义行为，包括程序崩溃、数据损坏或安全漏洞。

### 8.C语言中内存区域有哪些？
**代码区（Code Segment/Text Segment）**：存放CPU执行的机器指令。通常，代码区是只读的，以防止程序意外修改指令。
**全局数据区（Global Data Segment）**：
* 全局变量区：存放全局变量和静态变量（包括全局静态变量和局部静态变量）。
* 常量区：存放常量字符串和常量数据。
* 栈区（Stack Segment）：存放函数的局部变量、函数参数等。栈是自动管理的，每当函数调用时，系统就会为其分配栈空间，并在函数返回时自动释放这些空间。
* 堆区（Heap Segment）：用于动态内存分配。程序员通过malloc、calloc、realloc等函数手动分配内存，并通过free函数手动释放内存。堆区的大小不固定，且由程序员控制。

**变量生命周期**：
自动变量：这些变量在函数内部定义，其生命周期从定义点开始，到包含它的代码块执行完毕时结束。自动变量存储在栈区。
静态变量：包括全局静态变量和局部静态变量。全局静态变量在程序的整个运行期间都存在，但只能在其定义的文件内访问。局部静态变量在函数调用时不会被初始化多次，且其生命周期贯穿整个程序运行期，但仅在定义它的函数内可见。静态变量可以存储在全局数据区。
寄存器变量：这类变量存储在CPU的寄存器中，而不是内存中。
外部变量（External Variables）：这些变量在函数外部定义，通常在整个程序中可见。外部变量存储在全局数据区。

### 9.sizeof 运算符的值在编译时还是运行时确定?
sizeof运算符的值在大多数情况下是在编译时确定的。
因为sizeof是一个编译时的一元运算符，它用于计算数据类型或变量在内存中所占的字节数。当编译器遇到sizeof运算符时，它会查找运算对象的数据类型，并替换为该类型的大小（以字节为单位）。这个大小是在编译时就已经确定的，因此sizeof的结果不会受到程序运行时的影响。

### 10.sizeof 运算符返回的是什么类型的值?
sizeof 运算符返回的是 size_t 类型的值。
size_t 是一种无符号整数类型，用于表示对象的大小，特别是在内存管理或数组索引等场景中。
这个类型在 C 和 C++ 的标准库中定义（通常在 <stddef.h>），旨在提供一个足够大的整数类型，以容纳任何对象可能的大小。

### 11.哪些函数可以用来对 double 类型的变量进行舍入操作?
1. ceil 是C语言中的数学函数，用于向上取整。它的作用是返回大于或等于给定参数的最小整数值，即将参数向上取整到最接近的整数。
2. floor() 用于向下取整。它的作用是返回小于或等于给定参数的最大整数值，即将参数的小数部分舍弃，只保留整数部分。
3. round() 用于将浮点数四舍五入为最接近的整数。如果浮点数的小数部分大于0.5，则向上取整；如果小于0.5，则向下取整。

### 12.说明下列头文件的作用，stdio.h 、fcntl.h、sys/stat.h 和dirent.h？
1. stdio.h 是C语言标准输入输出库的头文件，它提供了一系列用于文件操作的函数，如文件的打开（fopen）、关闭（fclose）、读取（fread、fscanf、fgets等）、写入（fwrite、fprintf、fputs等）以及标准输入输出（如printf、scanf、putchar、getchar等）的函数。这是进行文件操作最常用的头文件之一。

2. fcntl.h 提供了对文件描述符进行操作的函数，如fcntl函数，它可以用来复制文件描述符、获取或设置文件状态标志、获取或设置文件锁等。虽然它主要用于文件描述符的底层操作，但在某些高级文件操作中也会用到。

3. sys/stat.h 提供了与文件状态相关的函数和数据结构，如stat和fstat函数，它们用于获取文件的状态信息（如文件大小、修改时间等）。此外，该头文件还定义了文件权限和文件类型等相关的宏和常量。

4. dirent.h 是UNIX系统下用于目录读取操作的头文件，它提供了一系列函数来读取目录中的条目（即文件和子目录）。虽然它主要用于目录操作，但在处理文件时（如遍历目录中的文件），它也是非常重要的。

### 13.说下C语言中运算符的优先级？
它们的优先级如下（从高到低）：
1. 括号（()）：用于改变表达式的默认求值顺序。
2. 一元运算符（如!、++、--、*、&等）：它们对单个操作数进行操作。
2. 算术运算符（如+、-、*、/、%）：用于数值计算。
3. 关系运算符（如==、!=、>、<、>=、<=）：用于比较两个表达式的值。
4. 逻辑运算符（如&&、||）：用于根据条件逻辑组合表达式。
5. 赋值运算符（如=、+=、-=等）：用于给变量赋值。

### 14.C语言中，哪哥函数可以在一个字符串中查找指定的子字符串?
```C
char *strstr(const char *haystack, const char *needle);
```
haystack是要搜索的字符串，needle是要查找的子字符串。
如果找到子字符串，strstr会返回一个指向子字符串第一次出现的指针；如果未找到，则返回NULL。这与问题要求的功能相匹配。
示例：
```C
#include <stdio.h>  
#include <string.h>  
  
int main() {  
    char haystack[] = "This is a sample string.";  
    char needle[] = "sample";  
    char *result;  
  
    result = strstr(haystack, needle);  
    if (result != NULL) {  
        printf("Substring found!");  
    } else {  
        printf("Substring not found\n");  
    }  
    return 0;  
}
```

### 15.C语言中有哪些作用域？
作用域（Scope）指的是程序中可以访问标识符（如变量、函数等）的区域。作用域决定了变量或函数在程序中的可见性和生命周期。

C语言中的作用域主要有以下几种：
1. 块作用域（Block Scope）
块作用域也称为局部作用域，是指在由一对花括号{}括起来的代码块内部声明的变量所具有的作用域。
这些变量只在其被声明的代码块内部有效，在代码块外部无法访问。块作用域的范围是从定义处到包含该定义的块的末尾。
例如，在函数内部或循环结构（如for、while、do-while循环）内部声明的变量就具有块作用域。

2. 文件作用域（File Scope）
文件作用域也称为全局作用域，是指在函数外部声明的变量或函数所具有的作用域。
这些变量或函数在整个源文件中都是可见的，但如果它们没有被声明为extern，则在其他源文件中是不可见的。
全局变量在程序开始执行时被创建，在程序结束时销毁。全局变量通常用于在不同函数之间共享数据。
这是静态变量（在文件级声明）的正确作用域。

3. 函数作用域（实际上与块作用域重合）
通常所说的函数作用域与块作用域是重合的，因为函数的参数和函数内部声明的局部变量都是在函数体的代码块内部有效的。
然而，需要注意的是，函数原型中的参数名只在函数原型内部有效，并不参与作用域规则。

4. 全局作用域
global 等声明的全局变量，在文件外部也是可见的。
全局变量（没有使用static关键字在文件级声明的变量）才具有全局作用域。

### 16.c语言在定义二维数组时，在给出所有初始化值的情况下，如果想省略一个维度，是可以省略行，还是省略列？
如果要省略一个维度，只能省略第一个维度（即行的数量），而不能省略第二个维度（即列的数量）。
C语言中的二维数组在内存中是连续存储的，**每一行都是连续的整数序列**，行与行之间则通过某种方式（通常是计算偏移量）来区分。
因此，编译器需要知道每一行有多少个元素（即列的数量），以便能够正确地计算整个数组的内存布局。

当你初始化二维数组时，如果你省略了第一个维度的大小，编译器可以根据你提供的初始化元素的数量和第二个维度的大小来推断出第一个维度的大小。但是，如果你省略了第二个维度的大小，编译器就无法知道每一行应该有多少个元素，因此这会导致编译错误。

例如，以下定义是合法的：
```c
int arr[][4] = {  
    {1, 2, 3, 4},  
    {5, 6, 7, 8},  
    {9, 10, 11, 12}  
};  
// 或者使用初始化列表（编译器会自动计算行数）  
int arr[][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
```
### 17.二叉查找树、二叉平衡树、红黑树的区别和联系？
区别
二叉查找树（BST）
定义：二叉查找树是一种特殊的二叉树，其中每个节点都满足左子树所有节点的值小于根节点的值，右子树所有节点的值大于根节点的值。
性能：在理想情况下，BST的查找、插入和删除操作的时间复杂度为O(logn)。然而，在树退化为链表时，操作时间复杂度会退化到O(n)。
特点：BST具有链表的快速插入与删除操作的特点，以及数组快速查找的优势。
二叉平衡树（如AVL树）
定义：二叉平衡树是为了解决BST退化为链表的问题而设计的。在AVL树中，**任何节点的两个子树的高度最大差别为1**，保持树的平衡。
性能：由于树的高度始终保持在logn左右，AVL树的查找、插入和删除操作的时间复杂度在最好和最坏情况下都保持在O(logn)。
特点：AVL树追求绝对平衡，每次插入或删除节点后，需要通过旋转来维持树的平衡。可能导致某些情况下，频繁的旋转会降低操作的效率。
红黑树
定义：红黑树是一种自平衡的二叉查找树，它通过特定的规则和旋转操作来保持树的平衡。
红黑树的每个节点都有一个颜色属性（红色或黑色），并满足一系列复杂的性质（如从根到叶子的最长路径不超过最短路径的两倍等）。
性能：红黑树能够在O(logn)的时间复杂度内进行查找、插入和删除操作。
与AVL树相比，红黑树在保持平衡方面的代价较低，因此在实践中往往具有更好的性能。
特点：红黑树并不追求“完全平衡”，而是允许一定的不平衡存在，这降低了对旋转操作的要求，从而提高了性能。同时，红黑树的算法时间复杂度和AVL树相同，但统计性能更高。
联系
基础：二叉查找树是所有高效查找树的基础，包括二叉平衡树和红黑树都是在它的基础上发展而来的。
目的：无论是二叉平衡树还是红黑树，它们的目的都是为了解决二叉查找树在最坏情况下性能退化的问题，通过保持树的平衡来提高查找、插入和删除操作的效率。

### 18.C语言中的字符串可以通过 sizeof() 函数获取其长度，判断对错？
在C语言中，sizeof() 函数用于获取对象或类型所占用的字节大小，它是一个编译时运算符，其结果在编译时就已确定。
对于字符串，如果直接使用 sizeof() 来获取一个字符串字面量或字符数组（包含字符串）的大小，它会返回整个数组（包括末尾的空字符 '\0'）所占用的字节数，而不是字符串的实际长度。
如：
```c
char str[] = "hello";  
printf("%zu\n", sizeof(str));  // 输出 6，因为数组 str 包含 5 个字符和 1 个 '\0'  
  
char *ptr = "world";  
printf("%zu\n", sizeof(ptr));  // 输出指针的大小，通常是 4 或 8，取决于系统架构，而不是字符串 "world" 的长度
```
要获取字符串的实际长度（不包括末尾的空字符 '\0'），应该使用 strlen() 函数，它是标准库函数，需要包含头文件 <string.h>。
如：
```c
#include <stdio.h>  
#include <string.h>  
  
int main() {  
    char str[] = "hello";  
    printf("%zu\n", strlen(str));  // 输出 5  
  
    return 0;  
}
```
在这个例子中，strlen(str) 正确地返回了字符串 "hello" 的长度（不包括末尾的空字符 '\0'）。

### 19.说明下常见的排序算法？
* 冒泡排序（Bubble Sort）：
原理：通过重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
特点：简单，但效率低，特别是对于大数据集。

* 选择排序（Selection Sort）：
原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
特点：不稳定排序，时间复杂度为O(n^2)，但实现简单。

* 插入排序（Insertion Sort）：
原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
特点：在数据规模较小时效率高，是稳定的排序方法。

* 快速排序（Quick Sort）：
原理：通过一趟排序将待排记录分隔成独立的两部分，其中一部分的所有记录均比另一部分的所有记录小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
特点：平均时间复杂度为O(nlogn)，但最坏情况下为O(n^2)，依赖于基准值的选择。

* 归并排序（Merge Sort）：
原理：是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
特点：稳定排序算法，时间复杂度为O(n log n)，但需要额外的存储空间。

* 堆排序（Heap Sort）：
原理：是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。
特点：不稳定排序，时间复杂度为O(n log n)，无需额外的存储空间。

* 希尔排序（Shell Sort）：
原理：是插入排序的一种更高效的改进版本。希尔排序又称为缩小增量排序，它将原来整个待排序的记录序列分割成为若干个子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。
特点：时间复杂度依赖于增量序列的选择，效率较高，但不稳定。

### 20.简述C++ 多态的实现方式有哪些？
多态性（Polymorphism）是面向对象编程（OOP）中的一个核心概念，它允许通过基类的指针或引用来调用派生类（子类）中重写（Override）或重载（Overload，但通常与多态性讨论中的意义不同）的函数。
C++ 中的多态性主要通过以下两种方式实现：
* 静态多态：
函数重载：允许函数名相同但参数列表不同的函数同时存在(参数个数、参数类型和参数顺序不同)。不能通过返回值重载函数。
原理：编译器对实际生成的函数名符号表进行修饰(结合类名字、函数名字、长度、参数类型等)，以区分不同重载函数的函数名。
![静态多态](image-2.png)
* 动态多态：
虚函数重写：这是 C++ 中实现多态的主要机制。通过在基类中将函数声明为虚函数，可以让派生类能够重写该函数，当通过基类指针或引用来调用该函数时，实际调用的将是派生类中的函数。
纯虚函数重写：将基类中的虚函数声明为纯虚函数（使用 = 0），可以将基类变为抽象基类（或称为接口类）。抽象基类不能被实例化，但它可以被用作基类来派生其他类。
原理：在基类中，将虚函数声明为纯虚函数后，编译器不会为其生成函数代码，而是会在派生类的**虚函数列表**(一维数组，里面存放了虚函数地址)中生成一个指向虚函数的指针。
![动态多态](image-3.png)

### 21.C++中override 和final关键字分别有什么作用？
![override与final关键字](image-4.png)
* override 关键字
用于明确指示一个成员函数是**重写了基类中的虚函数**。当使用 override 关键字时，编译器会检查该函数是否确实重写了基类中的虚函数。如果没有找到相应的虚函数进行重写，编译器会报错。有助于防止因拼写错误或函数签名不匹配而导致的重写失败问题。
```cpp
class Base {  
public:  
    virtual void func() {  
        // 基类实现  
    }  
};  
  
class Derived : public Base {  
public:  
    void func() override { // 明确表明这是重写  
        // 派生类实现  
    }  
};
```
* final 关键字
final 关键字有两个主要用途：
1. 阻止类被继承：final用于类定义时，表示该类不能被其他类继承，用于设计稳定的类库，防止不希望被继承的类被错误地继承。
2. 阻止虚函数被重写：final用于虚函数时，表示该函数在派生类中不能被重写，用于确保类的某些行为在继承体系中保持不变。
阻止类被继承：
```cpp
class FinalClass final {  
    // ...  
};  
// class DerivedFromFinal : public FinalClass {}; // 错误：FinalClass 不能被继承
```
阻止虚函数被进一步重写：
```cpp
class Base {  
public:  
    virtual void func() final {  
        // 基类实现  
    }  
};  
  
class Derived : public Base {  
    void func() override { // 错误：func() 在 Base 中被声明为 final  
        // 尝试重写  
    }  
};
```
这两个关键字共同增强了C++中面向对象编程的灵活性和安全性，使得代码更加清晰、易于理解和维护。

### 22.简述C++中智能指针的概念，并给出简单说明？
C++中的智能指针是一种特殊的指针类型，它旨在解决传统指针在资源管理中容易出现的内存泄漏和野指针问题。
智能指针通过自动管理资源（的生命周期来工作，确保资源在不再需要时能够被正确地释放。

C++标准库中提供了几种智能指针，其中最常用的是：
1. **unique_ptr**
std::unique_ptr：独享所有权的智能指针。
unique_ptr保证同一时间内只有一个unique_ptr可以指向某个对象。当unique_ptr被销毁时，它所指向的对象也会被销毁。unique_ptr不支持拷贝语义，但支持移动语义，这意味着你可以将一个unique_ptr的所有权转移给另一个unique_ptr。
2. **shared_ptr**
std::shared_ptr：共享所有权的智能指针。多个shared_ptr实例可以指向同一个对象，并共享对对象的所有权。
每个shared_ptr都维护一个内部计数器，该计数器跟踪有多少个shared_ptr指向该对象。当最后一个指向对象的shared_ptr被销毁或重置时，对象才会被删除(**引用计数**)。
3.**weak_ptr**
std::weak_ptr：非拥有性智能指针，用来解决shared_ptr之间可能导致的**循环引用问题**(学校和校长问题)。
weak_ptr可以指向一个由shared_ptr管理的对象，但它不拥有该对象，也就是说，它不会增加对象的引用计数。
因此，当对象的最后一个shared_ptr被销毁时，对象仍会被删除，即使还有weak_ptr指向它。
weak_ptr通常与shared_ptr一起使用，以便在不影响对象生命周期的情况下观察对象。