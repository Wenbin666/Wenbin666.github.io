---
title: Linux开发常见面试题（1）
date: 2020-11-13 15:54:31
tags: interview
categories: 
 - job
---
### 1. 字符型驱动设备是怎么创建设备文件的(/dev/下面的设备文件)，供上层应用程序打开使用的文件?
分手动创建和自动创建两类：
手动创建：
    通过mknod 命令创建，如：一个字符型驱动设备，主设备号为250，次设备号为0，那么可以使用mknod /dev/mydevice c 250 0命令来创建设备文件(其中c代表字符设备、b代表块设备)。
自动创建：
    1）通过udev规则匹配，udev是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件。这种方式在系统启动后或设备热插拔时自动进行(mdev是udev的简化版本，在嵌入式设备中使用)。
    2）通过devtmpfs创建，devtmpfs是内核中的一个特殊文件系统，用于在系统启动时快速创建和管理设备文件。devtmpfs在系统启动时由内核自动挂载，并在设备驱动程序注册时，内核会在devtmpfs中创建相应的设备文件。这些设备文件随后会被复制到/dev/目录下，或者通过udev进行进一步处理。

### 2. 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情怎么办?
注意事项：
* 快速响应中断：确保ISR能够快速响应中断请求，减少中断延迟。代码应该尽可能简洁，只执行最关键和必要的操作。
* 中断处理逻辑：根据中断源，在ISR中编写相应的处理逻辑。
* 中断嵌套与优先级：在处理中断时，考虑中断嵌套的可能性，并确保高优先级的中断能够优先得到处理。注意避免在ISR中执行可能阻塞或长时间运行的代码，以防止中断嵌套时发生死锁或降低系统响应降低问题。
* 清除中断标志：在ISR的最后，确保清除相应的中断标志，以避免中断被重复触发。

较多事情处理：
通过中断底半部处理，顶半部负责快速响应中断并触发底半部的执行，而底半部则负责完成中断处理的耗时任务。

* 中断顶半部（上半部）
主要任务：
1) 快速响应中断，执行尽可能少的、紧急的、不耗时的操作。
2) 读取硬件寄存器中的中断状态，并清除中断标志。
3) 将中断处理程序的底半部（下半部）放到该设备的底半部执行队列中，以便稍后处理。
特点：
执行速度快，可以服务更多的中断请求,通常被设计成不可中断的，以确保关键操作的原子性。主要处理与硬件紧密相关或时间敏感的任务。
* 中断底半部（下半部）
主要任务：
1) 完成中断事件的绝大多数任务，这些任务通常比较耗时或可以容忍一定的延迟。
2) 可以被新的中断打断，因为底半部的执行时机由系统自行安排，并不在中断服务上下文中执行。
特点：
相对于顶半部，底半部的执行更加灵活，可以处理更复杂的任务。底半部可以被中断，因此系统可以在处理底半部任务的同时响应其他中断，提高了系统的并发处理能力。底半部通常使用软中断、tasklet或工作队列等机制来实现。

### 3. 说明下中断底半部中工作队列、tasklet和软中断（softirq）的区别与联系。

* 工作队列（Workqueue）
定义与特点：
1) 工作队列是Linux内核中一种用于延迟执行任务的机制，它允许内核模块或驱动程序将耗时较长的操作推迟到进程上下文中执行，从而避免在中断上下文中执行这些操作可能导致的系统响应性下降。
2) 工作队列可以在多个CPU上并行执行任务，提高系统的吞吐量和响应性。

工作原理：
1) 当有任务需要异步处理时，内核会创建一个工作项（work_struct），并将其加入到工作队列中。
2) 内核中的工作队列守护进程（如kworker线程）会不断检查工作队列，一旦发现有待处理的工作项，就会将其取出并执行。
3) 工作项的执行是在进程上下文中进行的，因此可以执行需要睡眠的操作，也可以访问用户空间的数据。

适用场景：
1) 需要推迟执行的耗时操作。
2) 需要在进程上下文中执行的任务。
3) 可以并行处理以提高效率的场景。
4) 需要执行睡眠操作。

* 软中断（Softirq）
定义与特点：
1) 软中断是Linux内核中用于处理那些可以延迟执行的任务的一种机制。
2) 它允许内核将某些任务推迟到系统不太繁忙的时候执行，从而提高系统的整体性能。软中断可以在多个CPU上并行执行。

工作原理：
1) 当有任务需要异步处理时，内核会触发相应的软中断。
2) 软中断的处理函数会在内核的适当时机被调用，执行相应的任务。
3) 软中断，也是中断，它的执行是在软中断上下文中进行的，因此不能执行需要睡眠的操作或访问用户空间的数据。

适用场景：
1) 需要延迟执行的任务。
2) 可以在多个CPU上并行执行的场景。
3) 对时间要求不是非常严格的任务。

* Tasklet
定义与特点：
1) Tasklet是一种基于软中断实现的轻量级任务处理机制，它用于处理那些需要快速响应但又不需要立即完成的任务。
2) Tasklet可以在多个CPU上并行执行，但同一类型的tasklet在同一时刻只能在一个CPU上执行。

工作原理：
1) 当有任务需要异步处理时，内核会创建一个tasklet并将其加入到相应的tasklet队列中。
2) 当软中断被触发时，内核会检查tasklet队列，并执行其中的tasklet。
3) Tasklet的执行是在软中断上下文中进行的，因此不能执行需要睡眠的操作或访问用户空间的数据。

适用场景：
1) 需要快速响应但又不需要立即完成的任务。
2) 可以在多个CPU上并行执行的场景。

* 总结：
如果有睡眠需求，必须用workqueue，如果对性能有要求用softirq(毕竟是中断，快)，否则用tasklate。

### 4. Linux内核中处理互斥并发的机制主要有哪几种？

* 信号量（Semaphores）
概述：
1) 信号量是一种用于控制多个进程对共享资源访问的同步机制。
2) 它本质上是一个计数器，用于记录对某个资源（如共享内存）的存取状况。
3) 信号量允许多个进程（或线程）访问同一资源，但会限制同一时间内访问该资源的进程数。

特点：
1) 当信号量的值为正时，表示允许访问资源的进程数。
2) 进程在访问资源前需获取信号量，如果信号量为0，则进程进入等待状态。
3) 进程使用完资源后释放信号量，如果有等待的进程，则唤醒一个等待的进程。

应用场景：
适用于保护可能**长时间执行**的临界区，因为进程在等待信号量时可能会进入睡眠状态。

* 自旋锁（Spinlocks）
概述：
1) 自旋锁是一种低开销的同步机制，用于保护**短时间**的临界区。
2) 当自旋锁被某个执行单元（如CPU）持有时，其他想要获取该锁的执行单元会不断循环检查锁的状态，直到锁被释放。

特点：
1) 不会引起调用者睡眠，适用于保护执行时间非常短的临界区。
2) 在多处理器系统中，如果锁被长时间持有，自旋锁可能会导致CPU资源的浪费。

应用场景：
适用于中断上下文或短时间的内核临界区保护。

* 读写锁（Reader-Writer Locks）
概述：
读写锁是对自旋锁的一种改进，它允许多个读者同时访问共享资源，但写者与所有读者和写者之间是互斥的。

特点：
1) 提高了读操作的并发性，因为允许多个读者同时访问资源。
2) 写者在写入数据前需要独占访问权，此时会阻塞所有其他读者和写者。

应用场景：
适用于读多写少的场景，如文件系统的读操作和写操作。

* 原子操作（Atomic Operations）
概述：
1) 原子操作是指在执行过程中不会被其他代码中断的操作。
2) 在Linux内核中，原子操作通常通过汇编指令或特殊的CPU指令来实现。

特点：
1) 保证操作的原子性，即操作要么完全执行，要么完全不执行。
2) 不需要锁机制，减少了上下文切换和锁的竞争开销。

应用场景：
适用于简单的数据更新操作，如计数器的增减。

* 中断屏蔽（Interrupt Masking）
概述：
1) 中断屏蔽是一种通过禁用中断来防止竞态条件发生的同步机制。
2) 在访问共享资源的临界区之前，可以屏蔽中断，以防止中断处理程序打断正在执行的代码。

特点：
1) 简单有效，但可能导致中断延迟处理，影响系统响应性。
2) 不能长时间屏蔽中断，否则可能导致数据丢失或系统崩溃。
应用场景：
适用于单CPU系统中短时间的临界区保护。

* 互斥锁（Mutex）
概述：
1) 互斥锁是一种用于多线程编程的同步机制，旨在保护共享资源，防止多个线程同时访问导致的数据竞争和不一致问题。
2) 通过互斥锁，可以确保在任何给定时间点，只有一个线程能够访问被互斥锁保护的资源，其他线程则必须等待直到该线程释放锁。

特点： 
1) 互斥性：互斥锁的核心特性是确保在任意时刻，只有一个线程能够持有锁并访问受保护的资源。
2) 原子性：加锁和解锁操作是原子的，即这些操作在执行过程中不会被中断，从而保证了操作的完整性和一致性。
3) 阻塞与唤醒：当一个线程尝试获取已被其他线程持有的互斥锁时，该线程将被阻塞（挂起），直到锁被释放。一旦锁被释放，被阻塞的线程之一将被唤醒并尝试获取锁。

应用场景: 
多线程对共享资源的读写。
同步访问关键代码段。

* Completion完成量
1) Completion机制允许线程或任务在完成某项工作后通知其他线程或任务。
2) 这通常通过设置一个标志、发送信号或触发某个事件来实现。当被通知的线程或任务接收到完成通知时，它们可以继续执行后续操作。

特点
1) 同步性：Completion机制确保了线程或任务之间的同步，即一个线程或任务的完成状态可以准确地通知给其他线程或任务。
2) 高效性：通过减少不必要的轮询和等待时间，Completion机制可以提高程序的执行效率。
3) 灵活性：Completion机制可以与其他同步机制（如互斥锁、条件变量等）结合使用，以满足复杂的并发控制需求。

应用场景
1) 异步任务处理：在异步编程模型中，Completion机制用于通知调用者异步任务已完成，并传递任务结果。
2) 生产者-消费者模型：在生产者-消费者模型中，Completion机制可用于通知消费者有新的数据可供消费。
3) 事件驱动编程：在事件驱动编程中，Completion机制可用于在事件发生时通知相关的处理函数或方法。

### 5. 自旋锁和信号量在互斥使用时需要注意哪些? 在中断服务程序里面的互斥是使用自旋锁还是信号量?还是两者都能用? 为什么?
1) 使用自旋锁的进程不能睡眠，使用信号量的进程可以睡眠。
2) 中断服务例程中的互斥使用的是自旋锁，原因是在中断处理例程中，硬中断是关闭的，这样会丢失可能到来的中断。

### 6. 原子操作怎么理解?
概念：
1) 原子操作（Atomic Operation）是指在执行过程中不会被其他线程或进程中断的操作。
2) 该操作一旦开始，就会一直运行到结束，中间不会被任何其他操作打断,操作要么全部执行成功，要么完全不执行，不存在中间状态。

重要性: 
1) 保证数据一致性：在多线程或并发环境中，多个线程可能同时访问和修改同一个共享资源，这可能导致数据不一致的问题。原子操作可以确保在并发环境下对共享资源的访问是线程安全的，从而避免数据不一致的问题。
2) 避免竞态条件：竞态条件是指两个或多个进程或线程在访问共享资源时，由于执行顺序的不同而导致最终结果不同的现象。
3) 确保对共享资源的访问是原子的，即不可被分割，从而避免竞态条件的发生。

### 7. insmod 一个驱动模块，会执行模块中的哪个函数? rmmod呢?这两个函数在设计上要注意哪些? 遇到过卸载驱动出现异常没?是什么问题引起的?
1) insmod调用module_init函数，rmmod调用module_exit函数
2) 卸载模块时曾出现卸载失败的情形，原因是资源未释放完全，还在使用。

在设计module_init()和module_exit()函数时，需要注意以下几点：

1) 资源管理：在module_init()函数中申请的资源（如内存、I/O端口、中断号等），必须在module_exit()函数中对应地释放。
2) 错误处理：在初始化过程中，如果遇到无法恢复的错误，应该尽快释放已分配的资源，并返回错误码。在退出过程中，也应确保所有资源都能被正确释放，避免留下垃圾数据。
3) 同步和互斥：如果模块需要与其他模块或内核组件进行交互，应考虑同步和互斥问题，以避免数据竞争和死锁。
在卸载驱动时，确实可能会遇到异常情况，这些问题通常是由以下原因引起的：
1) 资源未释放：如果module_exit()函数未能正确释放所有在module_init()函数中申请的资源，就可能导致资源泄露或系统不稳定。
2) 设备正忙：如果模块被卸载时，仍有进程或其他模块正在使用该模块提供的设备或服务，就可能导致卸载失败。此时，系统通常会报告“设备或资源正忙”的错误。
3) 依赖关系未解决：如果模块之间存在复杂的依赖关系，而卸载操作未能正确解决这些依赖，就可能导致卸载失败或系统不稳定。

### 8. 在驱动调试过程中遇到过oops没?你是怎么处理的?
1) Oops（也称为内核错误或内核崩溃）是一个相对常见的问题，尤其是在开发或调试复杂的设备驱动程序时。
2) Oops是Linux内核在检测到无法恢复的内部错误时产生的，它会打印出错误信息和堆栈跟踪到控制台或日志文件中，帮助定位问题。

遇到Oops时的处理步骤：
1) 仔细阅读Oops信息，特别是错误代码和堆栈跟踪。这些信息通常会指出导致崩溃的具体位置（如文件名、函数名和行号）。
2) 回滚更改：如最近对驱动程序或系统进行了更改，尝试回滚这些更改，这有助于确定问题是否由最近的更改引起。
3) 使用如gdb、kgdb调试或crash工具来分析Oops时的内核转储文件。

### 9. 说明下ioctl的功能?
定义与用途：
1) ioctl是Input/Output Control的缩写，是一个系统调用函数。
2) 用于在设备驱动程序和用户空间进程之间传递特定的控制命令。
3) 允许用户空间程序与设备驱动程序进行通信，以实现对设备的控制和配置。

使用场景：
1) ioctl通常用于传统的Unix系统以及类Unix系统（如Linux、Mac OS X等）。
2) 它是设备驱动程序中对设备的I/O通道进行管理的函数，用于对设备的一些特性进行控制，例如串口的传输波特率等。
函数原型：
在应用程序中，ioctl函数的原型通常如下（定义在<sys/ioctl.h>头文件中）：
```c
int ioctl(int fd, unsigned long cmd, ...);
```
其中，fd是文件描述符，cmd是控制命令，后面的省略号表示可能有一个或多个参数，具体取决于cmd的意义。

### 10. 驱动中操作物理绝对地址为什么要先ioremap?
1) 因为内核没有办法直接访问物理内存地址，必须先通过ioremap获得对应的虚拟地址
2) ioremap将一个IO地址空间映射到内核的虚拟地址空间上去，便于访问

### 11. 设备驱动模型三个重要成员是? platfoem总线的匹配规则是? 在具体应用上要不要先注册驱动再注册设备?有先后顺序没?
三个成员：bus、platform_device和platform_driver,即总线、设备和驱动
匹配原理：当有一个设备新加入bus时，就去这个bus下寻找相应的驱动，通过platform_match函数，其实就是匹配compatible参数。
没有先后顺序，设备找驱动，驱动找设备。

### 12. linux中内核空间及用户空间的区别?用户空间与内核通信方式有哪些?

区别如下：
1) 定义方面：
+ 内核空间:操作系统内核运行的空间，包含系统内核代码、数据结构和设备驱动程序，负责管理和控制系统资源，提供各种系统服务。
+ 用户空间：用户程序运行的区域，包含应用程序代码、数据和堆栈等，是应用程序的运行环境，通过系统调用接口与内核进行交互。

2) 权限方面
+ 内核空间：具有最高的权限，可以直接访问和控制硬件资源，执行特权指令。	
+ 用户空间：权限受限，无法直接访问硬件资源，必须通过系统调用接口向内核发起请求。

3) 内存隔离
+ 内核空间和用户空间在内存中是分开的，有独立的地址空间。
+ 内核空间的地址空间通常是固定的，而用户空间的地址空间可以根据需要动态分配。

4) 资源访问	
+ 内核空间: 可以访问系统的所有资源，如文件系统、网络接口、设备驱动等。	
+ 用户空间: 只能通过系统调用接口向内核请求访问资源。

5) 安全性	
+ 内核空间: 由于具有最高权限，因此对内核空间的访问需要进行严格的控制，以防止恶意程序对系统造成破坏。	
+ 用户空间: 程序受限于权限，无法直接对系统进行修改，这有助于提高系统的安全性。

6) 运行环境	
内核空间: 操作系统内核的运行环境，它提供了操作系统的核心功能和服务。	
用户空间：是应用程序的运行环境，通过系统调用接口与内核进行交互。

用户空间与内核空间的通信方式：
1) 系统调用（System Call）
用户空间通过编写系统调用接口来调用内核提供的服务, open()、read()、write()、ioctl()、mmap()等。

2) 信号（Signal）
内核通过信号通知用户态进程发生了某些事件，用户态可以注册信号处理函数来响应特定的信号事件，如SIGTERM、SIGINT等。

3) 虚拟文件系统（如procfs、sysfs）：
这些文件系统提供了一种便捷的用户空间和内核空间的交互方式。如proc文件系统。

4) Netlink接口：
Netlink是一种用于用户态和内核态通信的socket接口，它提供了一种类似于BSD风格的API，支持内核先发起会话和异步通信。

5) get_user/put_user等内核函数：
这些函数在内核中被调用，用于在用户空间和内核空间之间传输数据。
+ get_user(x,ptr)用于获取用户空间指定地址的数值并保存到内核变量x中；
+ put_user(x,ptr)则用于将内核空间变量x的数值保存到用户空间指定地址处。

### 13. linux中内存划分及如何使用? 
13.1 内存划分
分为物理内存和虚拟内存：
物理内存: 硬件中实际存在的内存，由DRAM等半导体器件制成。
虚拟内存: Linux提供的一种内存抽象，它使得每个进程都拥有自己独立的地址空间。这个地址空间是虚拟的，不一定完全对应物理内存。虚拟内存的管理使得Linux能够更有效地利用物理内存，并支持比物理内存更大的内存使用量。

13.2 内存使用
在Linux中，内存的使用涉及多个方面，包括内存的申请、分配、使用和释放等。
1) 内存申请与分配:
+ 用户态内存申请：用户进程通过系统调用（如malloc、brk、mmap等）向内核申请内存。这些系统调用在内部会触发相应的内存管理机制，为用户进程分配虚拟内存（可能不立即分配物理内存）。
+ 内核态内存申请：内核模块或驱动在需要时也会申请内存，但通常使用不同的机制（如kmalloc、vmalloc等）。

2) 内存分配机制
分段与分页：Linux使用分段和分页机制将虚拟地址转换为物理地址。
+ 分段机制: 将逻辑地址转换为线性地址
+ 分页机制: 进一步将线性地址转换为物理地址。
Buddy系统：
+ Linux内核使用Buddy系统来管理物理内存页。
+ Buddy系统将相同大小的连续页框块用链表串起来，并通过拆分和合并来分配和释放内存，以减少内存碎片。
Slab分配器：
+ Slab分配器是对Buddy系统的补充，它用于分配小块内存。
+ Slab分配器将几个页单独拿出来作为缓存，以字节为单位进行分配，从而提高内存分配的性能。

3) 内存使用与释放
用户态内存使用：
    用户进程在获得内存后，可以根据需要进行读写操作。
    对于通过malloc等函数分配的内存，用户进程负责在不再需要时通过free等函数释放内存。
内核态内存使用：
    内核模块或驱动在获得内存后，也会根据需要进行读写操作。
    内核在不再需要这些内存时，会通过相应的机制（如kfree、vunmap等）释放内存。
4) 内存管理的其他方面
+ 内存映射：Linux支持将文件或其他对象的内容映射到进程的地址空间中，从而实现文件的高效读写和共享内存等功能。
+ 内存保护：Linux通过虚拟内存机制实现了对进程地址空间的保护，防止了进程间的非法访问和越界访问。
+ 内存回收：Linux内核会定期回收不再使用的内存页，并将其重新放入空闲页链表中，以便后续分配使用。

### 14. 虚拟地址及物理地址的概念及彼此之间如何转化?
虚拟地址：现代操作系统普遍采用虚拟内存管理机制时使用的地址。
物理地址：CPU地址总线传来的地址，由硬件电路控制其具体含义。
虚拟地址与物理地址之间的转化:
虚拟地址与物理地址之间的转化是由内存管理单元（MMU）完成的。MMU使用页表等数据结构来存储虚拟地址到物理地址的映射关系。当CPU访问一个虚拟地址时，MMU会查找页表，找到对应的物理地址，然后将访问请求发送到物理内存。

具体转化过程可以概括为以下几个步骤：
**地址分解**：MMU将虚拟地址分解为页号和页内偏移量两部分。页号用于在页表中查找对应的物理页基地址，页内偏移量则用于在物理页内定位具体的存储单元。
**页表查找**：MMU使用页号作为索引，在页表中查找对应的表项。页表项中存储了物理页基地址和其他一些控制信息，如页是否存在、是否可写等。
**地址合成**：MMU将页表项中的物理页基地址与页内偏移量合并，得到物理地址。然后，CPU使用这个物理地址来访问内存中的数据。
其他：
* 现代操作系统通常使用多级页表、TLB（Translation Lookaside Buffer，转换后备缓冲器）缓存等技术来优化地址转换的性能。
* 这些技术可以减少页表查找的次数，提高地址转换的速度。

### 15. 高端内存概念? 高端内存和物理地址、逻辑地址、线性地址的关系?
**高端内存**：
1) 通常指的是物理地址大于特定阈值的内存区域。
2) 由于内核直接映射空间的限制（通常只能映射1GB或更少的物理内存），对于大于该阈值的物理内存，无法直接通过内核映射进行访问，因此被称为高端内存。
3) 这些内存区域需要通过特殊的机制（如高端内存映射）来进行访问和管理。

高端内存和物理地址、逻辑地址、线性地址的关系
物理地址：机器中实际的内存地址，内存容量的直接表示。高端内存的物理地址大于特定阈值，因此无法直接通过内核映射进行访问。
逻辑地址：应用程序角度看到的内存单元或存储单元的地址，通常与段和偏移量相关。在高端内存的情况下，由于物理地址的特殊性，逻辑地址到物理地址的映射过程可能更加复杂。
线性地址：线性地址是逻辑地址到物理地址变换之间的中间层，是CPU所能寻址的空间或范围。
关系总结: 
+ 物理地址是高端内存的直接表示，但由于其特殊性（大于特定阈值），无法直接通过内核映射进行访问。
+ 逻辑地址是应用程序看到的地址，需要通过地址翻译器或映射函数转化为物理地址。在高端内存的情况下，这一过程可能更加复杂。
+ 线性地址作为逻辑地址和物理地址之间的中间层，在高端内存访问中起到桥梁作用。通过特殊的页表项或映射机制，可以实现线性地址到高端物理地址的转换。

### 16. linux中断的响应执行流程? 中断的申请及何时执行(何时执行中断处理函数)?
Linux中断的响应执行流程大致可以分为以下几个步骤：
1) 中断触发：当发生中断或者异常时，设备会向CPU发送一个中断请求，这个请求会被发送到CPU的中断控制器（如ARM的GIC）。
2) 中断接收与识别：中断控制器接收中断信号，并识别中断号, 中断号是唯一标识每个特定中断类型的数字。
3) CPU响应：
    CPU接收到中断信号后，会暂停当前正在执行的任务，并保存当前的程序计数器（PC）和处理器状态，以便之后恢复执行。
    CPU会向中断控制器发送一个中断确认信号，表示已经接收到中断请求。
    CPU检查中断屏蔽寄存器（Interrupt Mask Register），以确定是否允许该中断请求。如果中断被屏蔽，CPU将不会响应；
    否则，CPU将设置中断挂起寄存器（Interrupt Pending Register），准备处理中断。
4) 查找并执行中断处理程序：
    CPU根据中断号在中断描述符表（Interrupt Descriptor Table, IDT）或中断向量表中找到对应的中断处理程序的入口地址。
    CPU跳转到中断处理程序，开始执行具体的中断处理代码。在中断处理程序中，CPU会根据中断类型执行相应的操作，如读取设备数据、发送控制信号等。
5) 恢复现场并继续执行：
    中断处理程序执行完毕后，CPU会恢复之前保存的程序计数器（PC）和处理器状态。
    CPU向中断控制器发送一个结束中断信号，表示中断处理已经完成。中断控制器释放与该中断相关的资源，以便处理其他设备中断。
CPU继续执行被中断的任务。

Linux中断的申请及执行时机
1) 中断的申请：
在Linux中，中断的申请是通过调用内核API完成，如request_irq,此函数会注册中断处理函数，并将中断号与中断处理函数关联起来。
request_irq函数会使能中断，因此不需要手动去使能中断。一旦中断被激活，当相应的硬件设备产生中断时，中断处理函数就会被执行。
2) 中断处理函数的执行时机：
中断处理函数的执行时机是在CPU接收到中断信号并确认允许该中断后。CPU会暂停当前正在执行的任务，并跳转到中断处理程序执行相应的操作。

### 17. linux中的同步机制? spinlock (自旋锁)与信号量的区别?
spinlock等不到资源，就自旋，适合共享资源占用时间较短的场景。
信号量，等不到就睡眠，时候长时间占用共享资源的场景。

### 18. linux中RCU原理?
RCU(Read Copy Update)，顾名思义就是读--拷贝--修改，它是基于其原理命名的。
1) 对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它
2) 写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调(calback)机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。
3) 这个时机就是所有引用该数据的CPU都退出对共享数据的操作。

RCU介绍：
Linux RCU机制是一种用于实现**高效读取**和**并发更新数据结构**的同步机制。其主要作用可以归纳如下：
1) 提高读取操作的效率
无锁读取：RCU允许读取操作在无锁的情况下进行，避免了传统锁机制在读取时可能造成的阻塞和锁竞争开销，从而提高了读取操作的效率。
并发读取：在同一时间，可以有多个线程同时读取被RCU保护的数据结构，如链表、哈希表等，而不会相互干扰。

2) 保证数据一致性
延迟删除：在RCU中，当写者想要更新或删除数据时，它不会立即释放旧的数据结构，而是将其标记为“可回收”状态，并等待所有可能的读者完成读取操作后再进行实际的删除和回收。这种延迟删除的策略保证了数据的一致性，防止了读者在读取过程中遇到无效或不一致的数据。
宽限期机制：RCU使用“宽限期”（Grace Period）机制来确保所有的读者都已经完成了对旧数据的读取。在宽限期结束后，写者才能安全地回收旧数据。

3) 适用于读多写少的场景
优化读取密集型工作负载：RCU的设计哲学是优先保证读取操作的高性能和低延迟，而牺牲一部分写入操作的性能。这使得RCU非常适合于读取操作远多于写入操作的场景，如文件系统的目录查找、路由表的查询等。

4) 简化编程模型
减少锁的使用：RCU通过无锁读取和延迟删除的机制，减少了锁的使用和锁竞争带来的复杂性，使得并发编程模型更加简洁和高效。
降低编程难度：对于开发者来说，使用RCU可以更容易地编写出高性能、可扩展的并发程序，而无需担心复杂的锁管理和死锁问题。

5) 实际应用
在Linux内核中，RCU被广泛应用于多个子系统，如文件系统、网络协议栈等，以提高内核的并发性能和可扩展性。
RCU还被用于其他实时操作系统和并发编程框架中，以支持高效的读取和并发更新操作。

### 19. linux中软中断的实现原理?
中断服务程序往往都是在CPU关中断的条件下执行的，以避免中断嵌套而使控制复杂化，但是CPU关中断的时间不能太长，否则容易丢失中断信号。
Linux将中断服务程序一分为二，各称作"Top Half"和"Bottom Half”。
前者通常对时间要求较为严格，必须在中新请求发生后立即或至少在一定的时间限制内完成。因此为了保证这种处理能原子地完成，Top Half通常是在CPU关中断的条件下执行的具体地说。
Too Half的范电包括:从在IDT中登记的中断入口函数一直到驱动程序注册在中断服务队列中的ISR。
而Botom Hal则是TopHalf根据需要来调度执行的，这些操作允许延迟到稍后执行，它的时间要求并不严格，因此它通常是在CPU开中断的条件下执行的。但是，Linux的这种Botom Haf (以下简称BH)机制有两个缺点：
1) 在任意一时刻，系统只能有一个CPU可以执行Botom Hali代码，以防止两个或多个CPU同时来执行Botom Half函数而相互干扰。因此BH代码的执行是严格”串行化”的。
2) BH函数不允许嵌套。这两个缺点在单CPU系统中是无关紧要的，但在SMP系统中却是非常致命的。因为BH机制的严格串行化执行显然没有充分利用SMP系统的多CPU特点。
Linux2.4内核在BH机制的基础上进行了扩展，这就是所谓的“软中断请求”(softirq)机制。
Linux 的sofiro机制是与SMP紧密不可分的。为此，整个softiro机制的设计与实现中自始自终都贯彻了一个思想:“谁触发，谁执行”(Who marks，Who runs)，也即触发软中断的那个CPU负责执行它所触发的软中断，而且每个CPU都由它自己的软中断触发与控制机制。这个设计思想也使得softirq 机制充分利用了SMP系统的性能和特点。

### 20. linux系统实现原子操作有哪些方法?
1) 原子操作指令
原子操作指令是特殊的CPU指令，它们在执行过程中不会被中断。
ARM架构：ARM提供了一对独占内存加载和存储的指令（ldxr和stxr）支持原子操作.

2) 原子操作函数
Linux内核提供了一系列原子操作函数，这些函数封装了底层硬件提供的原子操作指令，为开发者提供了更高层次的抽象。这些函数通常以atomic_为前缀，如atomic_add、atomic_sub、atomic_inc、atomic_dec等。

3) 自旋锁（Spinlock）
自旋锁本身不是一种原子操作，但它通过禁用中断（使用本地中断禁用机制）来确保在获取锁的过程中不会被中断，从而间接实现了原子性。

4) 其他机制
如内存屏障（Memory Barrier）和原子变量类型（如atomic_t）
+ 内存屏障用于防止编译器或处理器对内存访问指令进行重排序，从而确保指令的执行顺序符合程序员的预期。
+ 原子变量类型则是一种特殊的变量类型，它提供了内置的原子操作支持。

### 21. 在uboot中如何操作设备的特定的寄存器?

U-Boot提供了一系列的命令行工具来查看和修改内存（包括寄存器）的内容。
常用的命令包括：
1) md：
Memory Display，用于显示内存的内容。可以通过指定地址和长度来查看寄存器或内存区域的值。
用法示例：md [.b, .w, .l] address [# of objects]
例如，要查看从地址0x30008000开始的20个字节的内容，可以使用md.b 0x30008000 20。

2) nm 和 mm：
用于修改内存值。nm用于直接修改指定地址的值，而mm则会在修改后自动将地址加一并等待用户输入新的值（通常用于连续修改）。
nm用法示例：nm [.b, .w, .l] address
mm用法示例：mm [.b, .w, .l] address

3) mw：Memory Write，用于用指定的数据填充内存。这在需要向寄存器写入固定值或清零时非常有用。
用法示例：mw [.b, .w, .l] address value [count]
例如，要向地址0xe0000204写入值0x00400000，可以使用mw.l 0xe0000204 0x00400000。

### 22. linux中系统调用过程?如:应用程序中read()在linux中执行过程即从用户空间到内核空间?

用户空间 -> 系统调用 -> vfs  -> file_operations -> read() 

### 23. 简述linux调度原理?

Linux调度原理是操作系统核心功能之一，它决定了CPU时间如何分配给系统中的各个进程。
以下是对Linux调度原理的简述：

1) 调度目标
Linux调度器的设计目标是实现以下几个方面的平衡：
+ 公平性：确保每个进程都能得到合理的CPU时间。
+ 高效性：使CPU保持忙碌状态，避免空闲。
+ 响应时间：缩短交互用户的等待时间。
+ 周转时间：减少批处理用户等待输出的时间。
+ 吞吐量：提高单位时间内处理的进程数量。

2) 调度策略与算法
支持多种调度策略和算法，以适应不同类型的进程需求：
+ 先来先服务（FCFS）：按进程到达的先后顺序进行调度，简单但可能不公平。
+ 时间片轮转（RR）：每个进程分配固定的时间片，时间片用完则切换到下一个进程，适用于分时系统。
+ 优先级调度：根据进程的优先级进行调度，优先级高的进程先运行。
+ 完全公平调度（CFS，Completely Fair Scheduler）：Linux 2.6及以后版本的主要调度器，基于进程的虚拟运行时间进行调度，确保每个进程得到公平的CPU时间。

3) 进程优先级
Linux中的进程优先级分为静态优先级（nice值）和动态优先级。
nice值可以通过系统调用（如nice和renice）设置，其范围从-20（最高优先级）到19（最低优先级）。
nice值实际上影响的是进程的权重，进而影响其CPU时间分配。动态优先级则是由系统根据进程的运行情况和系统负载动态调整的。

4) 调度器结构与类
Linux调度器采用模块化设计，允许多种调度算法并存。
每个进程都属于某个调度器类（如CFS、实时调度类等），由调度器类采用相应的调度策略进行调度。
调度器类按照优先级顺序排列，最高优先级的调度器类胜出，负责选择下一个运行的进程。

5) 抢占与上下文切换
Linux是抢占式多任务系统，即当前运行的进程可以被更高优先级的进程抢占。
当新进程到来或当前进程的时间片用完时，调度器会评估是否需要进行进程切换。
如果需要，则进行上下文切换，将CPU控制权交给新的进程。

6) 调度时机
Linux调度器在以下情况下会被触发：
* 进程状态转换（如从运行态转为睡眠态或终止态）。
* 当前进程的时间片用完。
* 硬件中断或系统调用返回用户态时。

7) 总结
Linux调度原理是通过多种调度策略和算法，结合进程优先级和模块化调度器结构，实现CPU资源的公平、高效和及时分配。
CFS调度器作为Linux 2.6及以后版本的主要调度器，通过基于虚拟运行时间的调度策略，确保了每个进程都能得到合理的CPU时间。

### 24. linux网络子系统的认识?

Linux网络子系统是Linux操作系统中负责网络通信和数据传输的核心组成部分。
网络子系统提供了一套完整的框架和工具，使得Linux系统能够高效地与各种网络设备和协议进行交互。

Linux网络子系统主要由以下几个关键部分组成：

1) 网络协议栈：
* 是网络通信的核心，负责管理网络数据包的传输和处理。
* 包括多个协议层，如物理层、数据链路层、网络层（IP协议）、传输层（TCP/UDP协议）和应用层。
* 每个层级负责不同的任务，如IP协议提供主机间的逻辑通信，TCP和UDP协议在传输层提供可靠或不可靠的数据传输。

2) 网络设备驱动：
* 负责处理计算机硬件设备与网络协议之间的交互。
* 提供了对网络硬件的访问和控制，包括网卡驱动程序等。
* Linux支持各种类型的网络设备，如以太网、Wi-Fi和蓝牙等。

3) 套接字层（Sockets）：
* 提供了一组API，使应用程序能够通过网络进行通信。
* 是网络通信的基本接口，为应用程序和底层网络协议之间提供了抽象层。

4) 网络管理工具：
* 提供了一系列命令和工具，使用户能够配置和管理网络连接。
* ifconfig命令用于配置网络接口，route命令用于设置路由表，iptables命令用于配置防火墙规则等。

### 25. linux内核里面，内存申请有哪些函数，各自的区别?
1) kmalloc()
```C
void *kmalloc(size_t size, gfp_t flags);
```
用于分配指定大小的内存块。
分配的内存位于内核物理内存映射区域，**物理上连续**，与真实的物理地址只有一个固定偏移值。
特点：
* 分配的内存块大小有限制，一般不超过128KB。
* 通过不同的flags参数可控制分配动作，如GFP_KERNEL（可能引起睡眠）、GFP_ATOMIC（不会引起睡眠，分配不到立即返回）。
* 分配的内存块在虚拟地址上是连续的。
释放函数：
```c
void kfree(const void *objp);
```

2) kzalloc()
```C
void *kzalloc(size_t size, gfp_t flags);
```
功能：与kmalloc()类似，但分配的**内存块会被自动初始化为0**。
特点：
* 分配的内存块大小同样有限制，不超过128KB。
* 内部实际上是通过kmalloc()分配内存，并附加了__GFP_ZERO标志来清零内存。
* 释放函数同样为kfree()。

3) vmalloc()
```C
void *vmalloc(unsigned long size);
```
功能：用于分配较大的内存块，大小可以超过kmalloc()的限制。
特点：
* 分配的内存块在虚拟地址上是连续的，但在**物理内存中可能不连续**。
* 分配过程可能需要建立新的页表，因此开销较大。
* 没有分配大小的限制。
* 由于可以睡眠，因此不能从中断上下文调用。
```C
void vfree(const void *addr);
```

### 26. IRQ和FIQ有什么区别，在CPU里面是是怎么做的?
1) 优先级：
FIQ具有比IRQ更高的优先级。当FIQ中断发生时，CPU会立即响应，**即使当前正在处理IRQ中断**也会暂停IRQ中断的处理。
2) 上下文保存：
FIQ中断处理时，会保存完整的CPU上下文（包括所有寄存器的状态），以确保中断处理完成后能够恢复到中断前的精确状态。
IRQ中断处理时，通常只保存部分CPU上下文（如程序计数器PC、链接寄存器LR等），以减少上下文保存和恢复的开销。
3) 栈使用：
FIQ使用专用的FIQ栈来处理中断，这有助于快速响应并减少上下文切换时的开销。
IRQ则通常使用主CPU栈来处理中断。
4) 应用场景：
FIQ一般用于处理需要快速响应的高优先级中断，如时间关键任务、DMA传输中断等。
IRQ则用于处理一般优先级的中断，如外设中断、I/O操作中断等。
5) 可屏蔽性：
FIQ中断是不可屏蔽的，即使CPU处于禁止中断状态（如CPSR寄存器的I标志位被设置），FIQ中断仍然能够响应。
IRQ中断则可以通过CPSR寄存器的I标志位来控制是否屏蔽。

### 27. 什么是优先级反转？
* 优先级反转（Priority Inversion）是一种多线程调度问题，尤其常见于实时系统或包含不同优先级线程的系统中。
* 问题发生时，高优先级的线程被一个或多个低优先级的线程阻塞，低优先级线程持有高优先级线程需要的资源（如互斥锁、信号量等）。
* 低优先级线程因某些原因（如等待I/O操作）无法释放资源，高优先级线程的执行被动延迟，即使其优先级高于当前持有资源的线程。

优先级反转的具体表现： 
* 资源竞争：高优先级线程需要访问低优先级线程已持有的资源。
* 执行延迟：由于资源被低优先级线程占用，高优先级线程被迫等待，导致执行延迟。
* 实时性受损：在实时系统中，这种延迟可能导致任务错过截止时间，违反实时约束。

优先级反转的危害：
* 系统性能下降：高优先级任务长时间等待资源，导致系统整体性能下降。
* 任务超时：实时任务可能因无法在规定时间内完成而超时，影响系统稳定性和可靠性。
* 系统崩溃：在极端情况下，优先级反转可能导致系统崩溃或重启。

为了解决优先级反转问题，可以采取以下几种策略：
1) 优先级继承（Priority Inheritance）：
* 当一个高优先级线程等待一个低优先级线程持有的资源时，低优先级线程的优先级会被临时提升到与高优先级线程相同。
* 低优先级线程在持有资源期间将不会被其他优先级较低的线程抢占，从而加快资源的释放。

2) 优先级天花板（Priority Ceiling）：
* 为每个共享资源分配一个优先级天花板，其优先级与所有请求该资源线程中最高的优先级。
* 当线程请求资源时，如果其优先级低于天花板，则将其优先级提升至优先级天花板。
这种方法可以确保持有关键资源的线程具有足够的优先级，以避免被其他线程抢占。

3) 避免共享资源：
通过设计避免线程之间的资源共享，可以减少优先级反转的发生。

4) 使用其他同步机制：
除了互斥锁和信号量外，还可以使用其他同步机制（如条件变量、读写锁等）来管理资源访问。
这些机制可能具有不同的调度行为，从而减少优先级反转的风险。

### 28. 线程安全是如何产生的？ 怎么避免？
* 线程安全问题主要源于多线程环境下对共享资源的并发访问。
* 当多个线程试图同时修改同一资源时，如果没有适当的同步机制，就可能导致数据不一致、竞态条件、死锁等问题。

线程安全问题产生的原因:
* 并发执行：多个线程同时运行，它们可能同时访问和修改共享资源，导致数据竞争和状态不一致。
* 非原子性操作：某些操作（如自增）在单线程中是原子的，但在多线程环境下可能不是，且可能被线程调度中断，导致数据不一致。
* 共享资源：当多个线程访问同一资源时，如果没有适当的同步机制，就可能发生数据冲突。
* 指令重排序：编译器和处理器为了优化性能，可能会对指令的执行顺序进行重排序。多线程下，这种重排序可能导致线程安全问题。

避免线程安全问题的方法：
1) 同步机制
* 互斥锁（Mutex）：确保同一时间只有一个线程能访问共享资源。
* 读写锁（Reader-Writer Locks）：允许多个线程同时读取共享资源，但写入时需要独占访问权。这可以提高读操作的并发性。
* 条件变量（Condition Variables）：用于线程间的同步，描述某种资源是否就绪的机制。
* 用原子操作, 对于简单的共享数据（如计数器、标志位等），可以使用原子操作来保证线程安全。
* 避免共享资源,尽可能避免线程间的资源共享，
* 使用线程安全的数据结构,设计或选择线程安全的数据结构，如线程安全的队列、栈等。这些数据结构内部已经实现了必要的同步机制。
* 避免复杂的同步逻辑, 简化同步逻辑可以减少死锁和资源饥饿的风险。在编写多线程程序时，应尽量避免嵌套锁和复杂的锁层次。
* 避免竞态条件, 通过合理的同步机制和设计来避免竞态条件的发生。

### 29. siziof如果传入参数是空的struct，返回值是多少？
1) 在C语言中，对一个空的struct使用sizeof操作符，虽然空的struct不包含任何成员，但编译器仍然需要为其分配内存空间
2) 这个空间需要满足特定的对齐要求。不同的编译器和不同的目标平台可能有不同的对齐规则。
3) 这个最小的对齐要求可能是1字节、2字节、4字节或其他值，具体取决于编译器和目标平台。
4) 实测gcc ubuntu中返回值为4。

### 30. 详细说明下malloc函数，如果传入size为0，返回值是多少？free可以传入空吗 
```C
void* malloc(size_t size);
```
参数：size 是请求分配的内存字节数。这个值必须是 size_t 类型的正整数。
返回值：
* 如果内存分配成功，malloc 返回一个指向分配的内存块的指针，该内存块的大小至少为 size 字节。
* 如果内存分配失败（例如，由于系统内存不足），则返回 NULL 指针。

传入0的情况：
1) 如果向malloc函数传入size为0，在大多数实现中，当size为0时，malloc通常会返回一个非空的指针
2) 这个指针指向一个大小至少为1字节的、不可访问的内存区域（即，你不能通过这个指针来读写数据，因为它可能不指向有效的内存）。
3) 应该避免对这样的指针进行解引用或写入操作，因为这样做可能会导致未定义行为，包括程序崩溃或数据损坏。
4) 即使malloc返回了一个非空指针，你也应该使用free函数来释放这块内存

free传空：
1) 向 free 传递 NULL 指针是安全的，free 会忽略它并立即返回。
2) 这可以作为一种防御性编程技术，用于在释放内存之前检查指针是否为 NULL。